<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smart Image Compression Test</title>
  <style>
    body {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
      line-height: 1.6;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 { color: #ffd700; }
    h2 { color: #4ade80; margin-top: 30px; }
    .upload-zone {
      border: 3px dashed #666;
      border-radius: 12px;
      padding: 60px;
      text-align: center;
      margin: 30px 0;
      cursor: pointer;
      transition: all 0.3s;
      background: rgba(255, 215, 0, 0.02);
    }
    .upload-zone:hover {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.05);
    }
    .results {
      background: #2a2a2a;
      padding: 25px;
      border-radius: 12px;
      margin-top: 30px;
    }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .info-card {
      background: #333;
      padding: 15px;
      border-radius: 8px;
      border-left: 3px solid #ffd700;
    }
    .info-card h3 {
      margin-top: 0;
      color: #ffd700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .info-card p {
      margin: 5px 0;
      font-size: 13px;
      color: #ccc;
    }
    .info-card .value {
      color: #fff;
      font-weight: bold;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 25px;
      background: #222;
    }
    th, td {
      padding: 12px;
      border: 1px solid #444;
      text-align: left;
    }
    th {
      background: #333;
      color: #ffd700;
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    td { font-size: 14px; }
    .badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 15px;
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
    }
    .badge-success { background: #065f46; color: #4ade80; }
    .badge-warning { background: #78350f; color: #fbbf24; }
    .badge-error { background: #7f1d1d; color: #f87171; }
    .badge-info { background: #1e3a8a; color: #60a5fa; }
    .metric {
      font-family: 'SF Mono', monospace;
      font-size: 12px;
      color: #999;
    }
    .console {
      margin-top: 25px;
      max-height: 400px;
      overflow-y: auto;
      background: #000;
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      font-family: 'SF Mono', monospace;
      border: 1px solid #333;
    }
    .console-line { margin: 2px 0; }
    .console-success { color: #4ade80; }
    .console-warning { color: #fbbf24; }
    .console-error { color: #f87171; }
    .console-info { color: #60a5fa; }
    .legend {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      padding: 15px;
      background: #222;
      border-radius: 8px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéØ Smart Image Compression Test</h1>
    <p style="color: #999; margin-top: -10px;">Testing intelligent compression with quality preservation</p>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot" style="background: #4ade80;"></div>
        <span>Optimal (preserved quality)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #60a5fa;"></div>
        <span>Good (minor compression)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #fbbf24;"></div>
        <span>Warning (heavy compression)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #f87171;"></div>
        <span>Error (over target/increased size)</span>
      </div>
    </div>
    
    <div class="upload-zone" onclick="document.getElementById('fileInput').click()">
      <h3>üì§ Click to upload test image</h3>
      <p>or drag & drop any image file</p>
      <p style="font-size: 12px; color: #666;">Supports JPG, PNG, WebP, AVIF</p>
      <input type="file" id="fileInput" accept="image/*" style="display: none" multiple />
    </div>

    <div id="results" class="results" style="display: none">
      <h2>üìä Compression Analysis</h2>
      
      <div class="info-grid" id="inputInfo"></div>
      
      <table id="resultsTable">
        <thead>
          <tr>
            <th>Size Variant</th>
            <th>Resolution</th>
            <th>Smart Target</th>
            <th>Format</th>
            <th>Quality</th>
            <th>Output Size</th>
            <th>Bytes/Pixel</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      
      <div id="summary" style="margin-top: 25px;"></div>
      
      <div id="console" class="console"></div>
    </div>
  </div>

  <script>
    // Console logging
    const logConsole = (msg, type = 'info') => {
      const consoleEl = document.getElementById('console');
      const className = `console-${type}`;
      consoleEl.innerHTML += `<div class="console-line ${className}">${msg}</div>`;
      consoleEl.scrollTop = consoleEl.scrollHeight;
    };

    // Override console.log
    const originalLog = console.log;
    console.log = function(...args) {
      originalLog.apply(console, args);
      const msg = args.join(' ');
      let type = 'info';
      if (msg.includes('‚úÖ')) type = 'success';
      else if (msg.includes('‚ö†Ô∏è')) type = 'warning';
      else if (msg.includes('‚ùå')) type = 'error';
      logConsole(msg, type);
    };

    // Smart compression functions (matching actual implementation)
    function calculateBytesPerPixel(fileSize, width, height) {
      return fileSize / (width * height);
    }
    
    function getMinimumQuality(fileSizeKB) {
      if (fileSizeKB < 50) return 0.7;    // Small files: preserve quality
      if (fileSizeKB < 200) return 0.5;   // Medium files: balanced
      if (fileSizeKB < 1000) return 0.4;  // Large files: moderate
      return 0.3;                         // Very large: aggressive
    }
    
    function getAdaptiveTarget(width, originalBytesPerPixel) {
      let targetBytesPerPixel;
      let maxSize;
      
      if (width <= 400) {
        targetBytesPerPixel = 0.5;
        maxSize = 100 * 1024;
      } else if (width <= 800) {
        targetBytesPerPixel = 0.4;
        maxSize = 200 * 1024;
      } else if (width <= 1200) {
        targetBytesPerPixel = 0.35;
        maxSize = 400 * 1024;
      } else {
        targetBytesPerPixel = 0.3;
        maxSize = 1024 * 1024;
      }
      
      // If original is already efficient, don't force compression
      if (originalBytesPerPixel <= targetBytesPerPixel) {
        targetBytesPerPixel = originalBytesPerPixel * 1.1;
      }
      
      const targetSize = Math.min(width * width * targetBytesPerPixel, maxSize);
      return { targetSize, targetBytesPerPixel };
    }
    
    async function processImage(file) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Load image
      const img = new Image();
      const url = URL.createObjectURL(file);
      
      return new Promise((resolve) => {
        img.onload = async () => {
          URL.revokeObjectURL(url);
          
          const results = {
            original: { 
              fileSize: file.size,
              fileName: file.name,
              width: img.width,
              height: img.height,
              bytesPerPixel: calculateBytesPerPixel(file.size, img.width, img.height)
            },
            sizes: []
          };
          
          // Display input info
          const inputInfo = document.getElementById('inputInfo');
          inputInfo.innerHTML = `
            <div class="info-card">
              <h3>Input File</h3>
              <p>Name: <span class="value">${file.name}</span></p>
              <p>Size: <span class="value">${(file.size/1024).toFixed(1)}KB</span></p>
              <p>Type: <span class="value">${file.type || 'unknown'}</span></p>
            </div>
            <div class="info-card">
              <h3>Image Properties</h3>
              <p>Resolution: <span class="value">${img.width} √ó ${img.height}</span></p>
              <p>Pixels: <span class="value">${((img.width * img.height) / 1000000).toFixed(2)}MP</span></p>
              <p>Aspect: <span class="value">${(img.width / img.height).toFixed(2)}:1</span></p>
            </div>
            <div class="info-card">
              <h3>Compression Analysis</h3>
              <p>Bytes/Pixel: <span class="value">${results.original.bytesPerPixel.toFixed(3)}</span></p>
              <p>Min Quality: <span class="value">${getMinimumQuality(file.size / 1024)}</span></p>
              <p>Efficiency: <span class="value">${
                results.original.bytesPerPixel < 0.2 ? 'Heavily compressed' :
                results.original.bytesPerPixel < 0.4 ? 'Well compressed' :
                results.original.bytesPerPixel < 0.6 ? 'Moderately compressed' :
                results.original.bytesPerPixel < 1.0 ? 'Lightly compressed' :
                'Uncompressed'
              }</span></p>
            </div>
          `;
          
          console.log(`\nüìÅ Input: ${file.name} (${(file.size/1024).toFixed(0)}KB, ${img.width}√ó${img.height}, ${results.original.bytesPerPixel.toFixed(3)} bytes/pixel)`);
          
          // Test different sizes with smart compression
          const sizes = [
            { width: 400, name: 'Small' },
            { width: 800, name: 'Medium' },
            { width: 1200, name: 'Large' },
            { width: Math.min(img.width, 2000), name: 'Original' }
          ];
          
          for (const size of sizes) {
            // Skip if larger than original
            if (size.width > img.width) continue;
            
            console.log(`\nüñºÔ∏è Processing ${size.name} (${size.width}px)...`);
            
            // Resize
            const aspectRatio = img.height / img.width;
            canvas.width = size.width;
            canvas.height = Math.round(size.width * aspectRatio);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Calculate smart compression parameters
            const totalPixels = canvas.width * canvas.height;
            const originalBytesPerPixel = file.size / (img.width * img.height);
            const adaptive = getAdaptiveTarget(size.width, originalBytesPerPixel);
            const minQuality = getMinimumQuality(file.size / 1024);
            
            console.log(`  Target: ${(adaptive.targetSize/1024).toFixed(0)}KB (${adaptive.targetBytesPerPixel.toFixed(3)} bytes/pixel)`);
            console.log(`  Quality range: ${minQuality.toFixed(2)} - 0.90`);
            
            // Determine starting quality based on efficiency
            let quality;
            if (originalBytesPerPixel < 0.3) {
              quality = 0.85;  // Already well-compressed, preserve quality
            } else if (originalBytesPerPixel < 0.5) {
              quality = 0.75;  // Moderately compressed
            } else if (originalBytesPerPixel < 1.0) {
              quality = 0.65;  // Lightly compressed
            } else {
              quality = 0.55;  // Uncompressed or inefficient
            }
            quality = Math.max(quality, minQuality);
            
            console.log(`  Starting quality: ${quality.toFixed(2)}`);
            
            // If already optimized, try high quality first
            let bestResult = null;
            if (originalBytesPerPixel < 0.4) {
              const highQualityAvif = await new Promise(resolve => 
                canvas.toBlob(resolve, 'image/avif', 0.85)
              );
              if (highQualityAvif && highQualityAvif.size <= file.size * 1.2) {
                console.log(`  ‚ú® Preserved quality: AVIF @0.85 = ${(highQualityAvif.size/1024).toFixed(0)}KB`);
                bestResult = { blob: highQualityAvif, format: 'AVIF', quality: 0.85 };
              }
            }
            
            // Smart compression if needed
            if (!bestResult) {
              const maxAttempts = 5;
              for (let attempt = 0; attempt < maxAttempts && quality >= minQuality; attempt++) {
                // Try AVIF
                const avifBlob = await new Promise(resolve => 
                  canvas.toBlob(resolve, 'image/avif', quality)
                );
                
                if (avifBlob) {
                  const avifBytesPerPixel = avifBlob.size / totalPixels;
                  console.log(`  AVIF @${quality.toFixed(2)}: ${(avifBlob.size/1024).toFixed(0)}KB (${avifBytesPerPixel.toFixed(3)} bytes/pixel)`);
                  
                  if (avifBlob.size <= adaptive.targetSize && avifBlob.size <= file.size * 1.2) {
                    bestResult = { blob: avifBlob, format: 'AVIF', quality };
                    break;
                  }
                  if (!bestResult || avifBlob.size < bestResult.blob.size) {
                    bestResult = { blob: avifBlob, format: 'AVIF', quality };
                  }
                }
                
                // Try WebP
                const webpBlob = await new Promise(resolve => 
                  canvas.toBlob(resolve, 'image/webp', quality)
                );
                
                if (webpBlob) {
                  const webpBytesPerPixel = webpBlob.size / totalPixels;
                  console.log(`  WebP @${quality.toFixed(2)}: ${(webpBlob.size/1024).toFixed(0)}KB (${webpBytesPerPixel.toFixed(3)} bytes/pixel)`);
                  
                  if (webpBlob.size <= adaptive.targetSize && webpBlob.size <= file.size * 1.2) {
                    if (!bestResult || webpBlob.size < bestResult.blob.size) {
                      bestResult = { blob: webpBlob, format: 'WebP', quality };
                      break;
                    }
                  }
                  if (!bestResult || webpBlob.size < bestResult.blob.size) {
                    bestResult = { blob: webpBlob, format: 'WebP', quality };
                  }
                }
                
                // Reduce quality gradually, respecting minimum
                quality = Math.max(minQuality, quality - 0.1);
              }
            }
            
            if (bestResult) {
              const finalBytesPerPixel = bestResult.blob.size / totalPixels;
              console.log(`  ‚úÖ Final: ${bestResult.format} @${bestResult.quality.toFixed(2)} = ${(bestResult.blob.size/1024).toFixed(0)}KB (${finalBytesPerPixel.toFixed(3)} bytes/pixel)`);
              
              results.sizes.push({
                name: size.name,
                width: size.width,
                height: canvas.height,
                target: adaptive.targetSize,
                targetBytesPerPixel: adaptive.targetBytesPerPixel,
                result: bestResult.blob,
                format: bestResult.format,
                quality: bestResult.quality,
                bytesPerPixel: finalBytesPerPixel
              });
            }
          }
          
          resolve(results);
        };
        
        img.src = url;
      });
    }

    // File input handler
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      document.getElementById('results').style.display = 'block';
      document.getElementById('console').innerHTML = '';
      
      const results = await processImage(file);
      
      // Display table
      const tbody = document.querySelector('#resultsTable tbody');
      tbody.innerHTML = '';
      
      results.sizes.forEach(size => {
        const row = tbody.insertRow();
        
        // Determine status
        let status, statusClass;
        const sizeRatio = size.result.size / results.original.fileSize;
        const qualityPreserved = size.quality >= 0.7;
        
        if (qualityPreserved && sizeRatio <= 1.0) {
          status = 'Quality preserved';
          statusClass = 'badge-success';
        } else if (size.result.size <= size.target && sizeRatio <= 1.2) {
          status = 'Good';
          statusClass = 'badge-info';
        } else if (size.result.size > size.target) {
          status = 'Over target';
          statusClass = 'badge-warning';
        } else if (sizeRatio > 1.2) {
          status = 'Size increased!';
          statusClass = 'badge-error';
        } else {
          status = 'Compressed';
          statusClass = 'badge-info';
        }
        
        row.innerHTML = `
          <td><strong>${size.name}</strong></td>
          <td>${size.width} √ó ${size.height}</td>
          <td>${(size.target/1024).toFixed(0)}KB <span class="metric">(${size.targetBytesPerPixel.toFixed(3)} b/px)</span></td>
          <td>${size.format}</td>
          <td>${size.quality.toFixed(2)}</td>
          <td><strong>${(size.result.size/1024).toFixed(0)}KB</strong></td>
          <td>${size.bytesPerPixel.toFixed(3)}</td>
          <td><span class="badge ${statusClass}">${status}</span></td>
        `;
      });
      
      // Summary
      const summary = document.getElementById('summary');
      const qualityPreserved = results.sizes.filter(s => s.quality >= 0.7).length;
      const oversized = results.sizes.filter(s => s.result.size > s.target).length;
      const increased = results.sizes.filter(s => s.result.size > results.original.fileSize * 1.2).length;
      
      let summaryHTML = '<h3>Summary</h3><div style="display: flex; gap: 15px; flex-wrap: wrap;">';
      
      if (qualityPreserved === results.sizes.length) {
        summaryHTML += '<span class="badge badge-success">‚ú® All variants preserved quality!</span>';
      } else if (qualityPreserved > 0) {
        summaryHTML += `<span class="badge badge-info">${qualityPreserved}/${results.sizes.length} preserved quality</span>`;
      }
      
      if (oversized === 0 && increased === 0) {
        summaryHTML += '<span class="badge badge-success">‚úÖ All compressions successful</span>';
      } else {
        if (oversized > 0) {
          summaryHTML += `<span class="badge badge-warning">‚ö†Ô∏è ${oversized} over target</span>`;
        }
        if (increased > 0) {
          summaryHTML += `<span class="badge badge-error">‚ùå ${increased} increased in size</span>`;
        }
      }
      
      summaryHTML += '</div>';
      summary.innerHTML = summaryHTML;
    });

    // Drag & drop
    const uploadZone = document.querySelector('.upload-zone');
    
    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = '#ffd700';
      uploadZone.style.background = 'rgba(255, 215, 0, 0.1)';
    });
    
    uploadZone.addEventListener('dragleave', () => {
      uploadZone.style.borderColor = '#666';
      uploadZone.style.background = 'rgba(255, 215, 0, 0.02)';
    });
    
    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = '#666';
      uploadZone.style.background = 'rgba(255, 215, 0, 0.02)';
      
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        document.getElementById('fileInput').files = e.dataTransfer.files;
        document.getElementById('fileInput').dispatchEvent(new Event('change'));
      }
    });
  </script>
</body>
</html>